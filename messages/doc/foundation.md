npm i -g @netjs/cli

nest new ${}

nest generate module ${}
좋네 리액트 rfc 느낌

npm run start:dev

nest generate controller messages(messags폴더 안에 만들어라)/messages(클래스이름) --flat(controllers폴더만들지마라)

오미친; 모듈에 업데이트도 지가알아서

### rest client

new file => requests.http
버전관리 가능해서 조하한다고함
오 ㅋㅋ 판타스틱하긴하네

### decorator

@Param
@Query
@Headers
@body

좋네 decorator

클래스 데코레이터/ 메서드 데코레이터
아큐먼트 데코레이터

npm install class-validator
npm install class-transformer

validationPipe => 대부분의 요청을 검증할 것임

Data transfer object => DTO => 데이터 전송 객체

class transformer 는 plain 객체를 받아서 클래스의 인스턴스로 변환하는 간단한 패키지

class validator
데코레이터를 이용해서 속성에 대한 검증을 처리함.

서버가 요청을 받으면 Validation Pipe로 들어감

Validation Pipe 는 class-transformer 로 DTO클래스로 인스턴스를 변환함.

그리고 데코레이터를 사용해서 검증함

### 타입정보가 js에서도 유효한 이유?

타입스크립트에 있는 데코레이터 와 DTO 타입은 js 에서 사라짐
타입스크립트는실행엔진이 아니라 컴파일 하는거

tsconfig의 emitDecortaor 옵션은 아주 적은 정보가 타입스크립트에서 자스로 넘어가게함
아주 적은 타입 어노테이션 정보가 자스로 변환됨

### 서비스와 리포지토리

서비스랑 리파지토리가 뭐가 다른지 정확히 이해해야 한다.

서비스와 리포지토리가 항상 클래스가될거임
NEST는 언제나 클레스를 만듦

비즈니스 로직을 작성할때는 늘 서비스를 만들 것임/ 계산을 실행하는 등의 작업
리포지토리로 부터 데이터를 가져올때도 서비스를 사용할 것임

리포지토리 자체는 저장할때 디비 상호작용 등의
작업을 할 때에 그걸 리포에 넣을 거임

거의 똑같은데도 프록시처럼 만들어두는건 의미가있음.다수의 다양한 리포랑 결합하거나 테스트 할떄

중복처럼보이지만 아주 유용하니까 날 믿고 따라와라

### 왜 인젝션이 존재하는가

컨트롤러 서비스 리포지퇴리가 현재까진 있고 아주 명확한 의존성 구조가있음.

서비스는 리포지토리에 의존하고
리포지토리가없으면 서비스는 동작하지않음

컨트롤러는 서비스에 의존함

컨트롤러와 서비스는 자체적으로 의존성을 생성함

의존성이 존재하는 이유? => 제어 역전 원칙

원칙에따르면 재사용 가능한 코드를 가지고싶으면
클래스 자체가 스스로의 의존성을 만들지말아야함

클래스 안에서 자체의 의존성을 생성하지 말아야 한다.

생성자의 인수로 만드는건 better

가장 좋은건 인터페이스를 만들어두고 받는거

왜냐면 이건 외부 타입에 의존되지도않으면서도 기존꺼도 잘 돌아감.

다른 클래스를 직접 참조하지않고 이걸 하면 아주 재미있는걸 할 수 있음 =>
제어역전원리를 잘따르고있다면 그런 메세들이 있는 객체를 나한테 준다면 나는 똑바로 동작할 것이다.

테스트 환경에서는
실제로 하드에 뭔갈 기록하거나 하지않더라도 가짜 Repository를 제공가능 인터페이스만맞으면.
음... 이런 거로군

## 의존성 주입 소개

제어역전에는 큰 단점이있음

제어 역전을 사용하기 시작하면 더 많은 코드를 작성해야 한다.

의존성 주입은 제어 역전을 이용하지만 엄청난 양의 코드를 작성안해도된다.

의존성 주입의 핵심은 컨테이너다 DI 컨테이너

injector

거꾸로 만들어서 가지고있는거에서 시작해서 Controller를 돌려주는건가

컨테이너의 목표는 모든 클래스를 기록하는것

컨테이너가 적절한 의존성을 생성하고 우리에게반환함

모든 의존성을 직접 생성할 필요가없음

DI 컨테이너 플로우

모든 클래스를 컨테이너에 등록한다

최초로 시작한 후에 컨테이너가 우리를 위해 클래스 인스턴스를 생성
그리고 그 클래스는 언제나 컨트롤러

컨테이너는 컨트롤러에 필요한 모든 의존성 확인하고

만든 뒤 우리에게 컨트롤럴ㄹ 반환함

일반적으로 서비스와 리포지토리를 등록

컨테이너가 인스턴스를 생성할때마다 저장하고 재사용하는게 중요한 핵심이다

둘 다 같은 인스턴스 요구하면 하나만 만들고 공유됨.

확인할수있는 방법은 간단 사본 몇개 만들고 console.log === 해보면 다 true

이걸 생각해보면 다 공유된다고 생각하고 하게됨

그래서 만일 계속 새ㅗㄹ운게 필요하다면 그렇게 할 수있으니 걱정 ㄴ

종종 di 하고있으면 왜 하고있나 하는 생각이듦

확실한건 테스트할때 이걸 다 사용하면 테스트가 아주 쉬워짐
