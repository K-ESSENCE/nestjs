### 인증의 기본

어느 시점에 클라가 웹이던 모바일이던 요청을 보냄 , 가입을 목적으로

서버 >> 이미가입되었는지 확인 / 암호화 / 저장 / 쿠키 보냄

클라 >> 쿠키 저장 / 요청

그 다음부터는 쿠키정보 훼손 되었는지 확인 한 후 디비에서 조회

서비스의 크기가 크면 Auth Service를 따로 만드는게 훨씬 낫다.

인증서비스라는 새로운 서비스를 만들거임 => 가입과 로그인 기능을 담당함

### 서비스 셋업 복습

유저 모듈안에 서비스들의 상관관계를 확인해보고 갔으면 좋겠다.

4개의 클래스가 이제 들어간다

유저 서비스, 인증서비스, 유저 컨트롤러, 유저 레파지토리

유저서비스랑 레포지토리랑 연결되어있고
유저가 인증서비스랑 연결되어있음

각각의서비스는 컨트롤러랑 연결되어있고

DI 플로우 => 의존성 주입이 가능하다고 표시 (모듈의 프로바이더에 추가)

### 해시처리 ?

Hashing Function

Node standard library에서는 crypto 모듈을 사용함

crypto.randomBytes(32).toString('hex')

뭐 입력값 바꾸면 다른 값 나오고

해시되고 나면 값이 뭔지 알 수 없다.

비밀번호 해쉬 시키고 그걸 db에 넣을거임

그러면 비밀번호 비교할때도 해쉬된 비밀번호끼리 비교해야됨

해심값이 같으면 로그인 시킨다고그걸 설명하네

사람들이 흔히 사용하는 흔한 비번 iloveyou 이런걸로 뚫는다고

레인보우 테이블 공격 => 전세계적으로 잘 쓰이는 비밀번호 목록 넣어둠

해시값 비교해보고 이 사람 ㅐㅍ스워드는 이거겠네 해서 사용자의 이메일도 마저 알아냄.

그럼 이걸로 로그인

이런 레인보우 테이블 공격에 대비하는 방법? => Salt Value

Salt? => random value

사용자의 비밀번호+Salt 붙여서 hash

Hashed and Salted Password

hash 부분이랑 salt 부분이랑 따로 저장함 그래서 우리는 어디가 솔트인지 안다고.
그럼 이걸 하나로 합치고 이걸 해시에 넣으면 이게 우리의 Hash

어렵다고 느껴다면 걱정하지마라 코드는 개 간결하다고
